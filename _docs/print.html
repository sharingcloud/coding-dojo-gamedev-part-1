<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coding Dojo - Gamedev Part 1</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Gamedev Part 1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="HOME.html">Introduction</a></li><li><a href="PREREQUISITES.html"><strong aria-hidden="true">1.</strong> Pré-requis</a></li><li><a href="THEORY-GAMEDEV.html"><strong aria-hidden="true">2.</strong> Théorie - Game development</a></li><li><a href="THEORY-GODOT.html"><strong aria-hidden="true">3.</strong> Théorie - Godot Engine</a></li><li><a href="PRACTICE-GODOT.html"><strong aria-hidden="true">4.</strong> Pratique - Prise en main de Godot</a></li><li><a href="PRACTICE-NODES.html"><strong aria-hidden="true">5.</strong> Pratique - Jouer avec les nodes</a></li><li><ol class="section"><li><a href="PRACTICE-NODES-STARS.html"><strong aria-hidden="true">5.1.</strong> Un fond et des étoiles</a></li><li><a href="PRACTICE-NODES-ENEMY.html"><strong aria-hidden="true">5.2.</strong> Des ennemis</a></li><li><a href="PRACTICE-NODES-HUD.html"><strong aria-hidden="true">5.3.</strong> Un HUD pour le score</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Coding Dojo - Gamedev Part 1</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Bienvenue sur ce Coding Dojo un peu spécial.</p>
<p>Aujourd'hui, on va découvrir le fabuleux monde du <em>gamedev</em> et <strong>apprendre à créer un jeu vidéo</strong> !</p>
<p>Vous allez voir, ça sera plus simple que ça en a l'air !</p>
<p style="text-align: center">
  <br />
  <br />
  <br />
  <img src="./assets/you-can-do-it.jpg">
</p>
<h1><a class="header" href="#pré-requis" id="pré-requis">Pré-requis</a></h1>
<p>Avant de commencer notre session, vous aurez besoin de:</p>
<p style="text-align: center;">
<img src="./assets/windows-logo.png" width="150" height="150" />
</p>
<ul>
<li>Windows: même si ce moteur qu'on va utiliser est compatible Linux et Mac, on va se concentrer sur Windows aujourd'hui.</li>
</ul>
<p style="text-align: center;">
<img src="./assets/vscode-logo.png" width="150" height="150" />
</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a>: normalement tout le monde sait déja ce que c'est, et tout le monde devrait l'avoir d'installé.
<ul>
<li>Disponible ici: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
</ul>
</li>
</ul>
<p style="text-align: center;">
<img src="./assets/godot-logo.png" width="150" height="150" />
</p>
<ul>
<li><a href="https://godotengine.org/">Godot Engine 3.1.1</a>: le moteur de jeu open-source que je vais vous présenter aujourd'hui.
<ul>
<li>Disponible ici <a href="https://godotengine.org/download/windows">https://godotengine.org/download/windows</a></li>
</ul>
</li>
</ul>
<p>Même si Godot contient un éditeur intégré, je conseille quand même Visual Studio Code parce qu'il est quand même plus pratique et plus riche en fonctionnalités.</p>
<h1><a class="header" href="#théorie---game-development" id="théorie---game-development">Théorie - Game development</a></h1>
<p style="text-align: center">
  <img src="./assets/joystick.png" width="250" height="250" />
</p>
<h2><a class="header" href="#cest-quoi-le-game-development-gamedev-" id="cest-quoi-le-game-development-gamedev-">C'est quoi le game development (gamedev) ?</a></h2>
<p>Je vais volontairement vulgariser les choses et aller vite sur le sujet, vu que c'est un sujet hyper vaste.</p>
<p>Le gamedev c'est (en gros) le domaine où l'on <strong>conçoit des jeux vidéos de A à Z</strong>.</p>
<p>Le gamedev est une branche du développement très complexe et passionante, considérée parmi les branches les plus difficiles du monde du développement. Quand on réalise un jeu, surtout avec un point de vue et des compétences de développeur, on a finalement besoin de pas mal de sujets à explorer.</p>
<p>Entre autres, il faut s'occuper:</p>
<ul>
<li>De la partie <strong>gameplay</strong>: mettre en place une bonne mécanique de jeu</li>
<li>De la partie <strong>scénario</strong>: il faut bien une histoire ou alors un environnement cohérent</li>
<li>De la partie <strong>graphique</strong>: des sprites, des tilemaps, des backgrounds, n'importe quelle ressource graphique</li>
<li>De la partie <strong>son</strong>: effets sonores et musiques, interaction des sons avec le gameplay</li>
<li>De la partie <strong>réseau</strong>: pour le multijoueur c'est quand même mieux (après il est possible de faire du split-screen à l'ancienne)</li>
<li>De la partie <strong>physique</strong>: collisions et réactions plus ou moins réalistes</li>
<li>De la partie <strong>moteur/engine</strong>: le(s) système(s) sous-jacent(s) qui s'occupe(nt) de tout coordonner</li>
<li>Et encore d'autres parties spécialisées comme par exemple le <strong>scripting</strong> pour dynamiquement exécuter du code lors du level design</li>
</ul>
<p>Vous aurez compris, pour chacune de ces parties, on peut nécessiter une ou plusieurs personnes à temps plein (notamment la partie <strong>engine</strong> qui est la plus technique).</p>
<p>Seulement, dans le monde d'aujourd'hui, il est entièrement possible de créer un jeu <em>en solo</em> (ou <em>en équipe réduite</em>), il faut juste de la <strong>patience</strong>, de l'<strong>investissement</strong>, de la <strong>réflexion</strong>, et surtout beaucoup de <strong>pratique</strong>.</p>
<p>Il y a une règle que j'ai lu quelque part qui dit en gros que <em>&quot;tes dix premiers jeux vidéos seront plutôt mauvais, et après ça ira mieux&quot;</em>.
Donc il faut pratiquer.</p>
<h2><a class="header" href="#comment-on-fait-un-jeu-en-pratique-" id="comment-on-fait-un-jeu-en-pratique-">Comment on fait un jeu en pratique ?</a></h2>
<p>Il y a en gros <strong>trois</strong> manières de faire un jeu vidéo.</p>
<h3><a class="header" href="#sans-rien" id="sans-rien">Sans rien</a></h3>
<p>La première, c'est de <strong>partir de zéro</strong> en mode <em>warrior</em>, avec son langage préféré et son couteau. D'ailleurs le langage préféré est un peu biaisé ici, dans le monde du gamedev on utilise surtout C++.</p>
<p>Autant vous dire que c'est la manière la plus difficile, qu'il y a juste énormément de choses à gérer pour faire tourner son jeu ne serait-ce que sur une seule plateforme, et que comme il faut tout faire à la main ça demande énormément de temps puisque tout va devoir se faire en code, sauf si vous prenez en plus le temps de faire des éditeurs.<br />
On ne va donc pas faire ça aujourd'hui, même si d'un point de vue éducationnel, ça peut être hyper enrichissant de faire son propre jeu (ou son propre framework, voire son propre moteur de jeu) depuis zéro (ou depuis un petit framework).</p>
<p>Dans le monde professionnel, et surtout à l'époque, la plupart des jeux sont crées de cette manière là, avec un contrôle total où l'équipe chargée du développement du jeu s'occupe aussi de la réalisation de tout ce qu'il y a sous le jeu.</p>
<h3><a class="header" href="#avec-un-game-framework" id="avec-un-game-framework">Avec un game framework</a></h3>
<p>La deuxième technique, c'est d'utiliser un <strong>framework</strong>. Tout comme dans le monde du développement web qu'on connaît désormais assez bien, il existe des <strong>frameworks</strong> qui exposent déjà la plupart des fonctionnalités complexes, il faut juste se servir et composer son jeu via les primitives. Voici des exemples connus de frameworks:</p>
<ul>
<li>
<p>Frameworks plutôt minimalistes:</p>
<ul>
<li><a href="https://www.libsdl.org/">SDL (C)</a>: Bonne base pour construire autour, gère la partie cross-platform et gestion de la fenêtre et des évènements. Plusieurs bindings dans d'autres langages.</li>
<li><a href="https://www.sfml-dev.org/">SFML (C++)</a>: Equivalent plus haut niveau de la SDL, plus de fonctionnalités. Plusieurs bindings dans d'autres langages.</li>
</ul>
</li>
<li>
<p>Frameworks plus complets:</p>
<ul>
<li><a href="https://libgdx.badlogicgames.com/">LibGDX (JVM)</a>: Framework complet plutôt simple à utiliser.</li>
<li><a href="https://phaser.io/">Phaser (JS)</a>: Contient une super documentation avec pas mal d'exemples, et tourne sur le navigateur.</li>
<li><a href="http://www.monogame.net/">XNA/MonoGame (C#)</a>: Le bon vieux projet XNA réalisé par Microsoft pour faire des jeux cross-platform Windows/Xbox 360 a l'époque. Beaucoup de jeux indépendants connus ont été réalisés via XNA, dont <em>Super Meat Boy</em>, <em>Bastion</em>, <em>Fez</em> et bien d'autres.
<ul>
<li>XNA ayant été &quot;tué&quot; par Microsoft, le projet MonoGame à pris le relais, se basant sur le projet Mono pour apporter la cross-compatibilité sur la plupart des plateformes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Mention spéciale pour le langage Haxe et les projets par dessus (comme <a href="http://haxeflixel.com/">HaxeFlixel</a>), qui possède un concept super cool que je vous invite à regarder sur leur <a href="https://haxe.org/">site officiel</a>. Pour le teasing, <em>Dead Cells</em> a été réalisé en Haxe.</p>
<h3><a class="header" href="#avec-un-game-engine" id="avec-un-game-engine">Avec un game engine</a></h3>
<p>Finalement, la troisième technique, c'est le <strong>moteur de jeu (game engine)</strong>, qui expose un maximum de fonctionnalités à travers une interface pour faire son jeu d'une façon beaucoup plus interactive. Dans le domaine du game engine, il y a en gros deux types: les moteurs spécialisés, et les moteurs plutôt génériques.</p>
<ul>
<li>
<p>Moteurs de jeu spécialisés:</p>
<ul>
<li><a href="https://fr.wikipedia.org/wiki/MUGEN_(moteur_de_jeu)">M.U.G.E.N</a>: Ce &quot;moteur&quot; sert à réaliser votre propre jeu de combat à la <em>Street Fighter</em>. Super fun à utiliser.</li>
<li><a href="http://www.rpgmakerweb.com/">RPG Maker</a>: Celui-ci sert à réaliser son propre RPG, du classique <em>Final Fantasy</em> à <em>Zelda</em> en passant par <em>Pokémon</em> (si on plie bien le système).</li>
<li><a href="http://www.rpgmakerweb.com/">Adventure Game Studio</a>: Pour faire ses propres jeux en point-and-click.</li>
</ul>
</li>
<li>
<p>Moteurs de jeu génériques:</p>
<ul>
<li><a href="https://www.yoyogames.com/gamemaker">Game Maker</a>: Un soft payant plutôt facile à prendre en main pour réaliser n'importe quel type de jeu (surtout dédié aux jeux 2D). Je conseille aussi <a href="https://www.scirra.com/">Construct</a> dans le même genre.</li>
<li><a href="https://godotengine.org/">Godot Engine</a>: Un super moteur open-source 2D et 3D pour réaliser n'importe quel type de jeu que je vais vous présenter aujourd'hui.</li>
<li><a href="https://unity.com/fr">Unity3D</a>: Sûrement le moteur de jeu le plus connu aujourd'hui. Blindé de features, énormément de jeux réalisés avec, payant pour la version Pro (si on veut un thème sombre par exemple).</li>
<li><a href="https://www.cryengine.com/">CryEngine</a>: Le moteur de jeu open-source made in Crytek, les créateurs de <em>Crysis</em>. Assez lourd et nécessite un PC plutôt performant.</li>
<li><a href="https://www.unrealengine.com/en-US/">Unreal Engine</a>: Le monstrueux moteur de jeu open-source made in Epic Games, entre autres créateurs d'<em>Unreal Tournament</em>. Cette chose est massive, blindée de choses utiles, bouffe pas mal d'espace disque, de RAM, de CPU et de GPU. Fait souffrir les PCs portables non-adaptés pour le jeu.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#théorie---godot-engine" id="théorie---godot-engine">Théorie - Godot Engine</a></h1>
<p style="text-align: center">
  <img src="./assets/godot-logo.png" width="250" height="250" />
</p>
<h2><a class="header" href="#présentation-de-godot-engine" id="présentation-de-godot-engine">Présentation de Godot Engine</a></h2>
<p>Godot Engine est un moteur complètement open-source, assez jeune dans le monde du gamedev, mais super prometteur.</p>
<p>Pour avoir plus d'informations, vous pouvez directement aller sur leur <a href="https://godotengine.org/">site officiel</a>.</p>
<blockquote>
<p>Godot Engine is a feature-packed, cross-platform game engine to create 2D and 3D games from a unified interface. It provides a comprehensive set of common tools, so users can focus on making games without having to reinvent the wheel. Games can be exported in one click to a number of platforms, including the major desktop platforms (Linux, macOS, Windows) as well as mobile (Android, iOS) and web-based (HTML5) platforms.</p>
<p>Godot is completely free and open source under the permissive MIT license. No strings attached, no royalties, nothing. Users’ games are theirs, down to the last line of engine code. Godot’s development is fully independent and community-driven, empowering users to help shape their engine to match their expectations. It is supported by the Software Freedom Conservancy not-for-profit.</p>
</blockquote>
<blockquote>
<p>Create games with ease using Godot's unique approach to game development.</p>
<ul>
<li><strong>Nodes for all your needs</strong>. Godot comes with hundreds of built-in nodes that make game design a breeze. You can also create your own for custom behaviors, editors and much more.</li>
<li><strong>Flexible scene system</strong>. Create node compositions with support for instancing and inheritance.</li>
<li><strong>Visual editor</strong> with all the tools you need packed into a beautiful and uncluttered context-sensitive UI.</li>
<li><strong>Friendly content creation pipeline</strong> for artists, level designers, animators and everyone in between.</li>
<li><strong>Persistent live editing</strong> where changes are not lost after stopping the game. It even works on mobile devices!</li>
<li><strong>Create your own custom tools</strong> with ease using the incredible tool system.</li>
</ul>
</blockquote>
<p style="text-align: center">
  <img src="./assets/godot-editor.png" />
  <br />
  <i>Voici l'éditeur de Godot</i>
</p>
<p>Pour la partie scripting, Godot permet de développer dans plusieurs langages de programmation:</p>
<ul>
<li><strong>GDScript</strong> (principalement utilisé): un langage fait maison, qui reprend énormément de principes à Python. Permet d'écrire peu de code pour faire beaucoup.</li>
<li><strong>C#</strong> (via Mono): un langage qui a déja fait ses preuves (dans le monde du gamedev il est principalement utilisé dans Unity), mais son intégration dans Godot est encore un peu instable, sans support pour le mobile actuellement.</li>
<li><strong>C++</strong> (code natif): à l'ancienne, retour du mode warrior.</li>
<li><strong>Rust, Python, et autres</strong> (via GDNative): il est possible de faire du code natif dans d'autres langages si besoin, c'est cependant plus complexe à mettre en place.</li>
</ul>
<h2><a class="header" href="#présentation-du-projet-un-space-shooter" id="présentation-du-projet-un-space-shooter">Présentation du projet: un space shooter</a></h2>
<p>On va entrer dans le vif du sujet: aujourd'hui on va faire un space shooter, on va donc faire le tour de ce qu'est un space shooter.</p>
<p>Oui c'est en effet un &quot;jeu de tir dans l'espace&quot;, mais voici des caractéristiques plus spécifiques (et surtout utiles):</p>
<ul>
<li>On va faire un jeu <strong>en 2D</strong> (pour éviter de se cramer les ailes avant de partir),</li>
<li>On va <strong>diriger un vaisseau</strong> qui <strong>tire</strong> sur <strong>des rochers</strong> et <strong>des ennemis</strong>,</li>
<li>Le scrolling va être <strong>vertical</strong>, donc du haut vers le bas (plutot que horizontal),</li>
<li>En gros voilà.</li>
</ul>
<p>Pour cela, on va utiliser un pack de contenu déja fait pour réaliser notre space shooter, réalisé par Kenney, qui propose des super packs pour plusieurs types de jeux vidéos.</p>
<p>Voici le pack en question: <a href="https://www.kenney.nl/assets/space-shooter-redux">https://www.kenney.nl/assets/space-shooter-redux</a>, et un exemple de jeu réalisé juste avec ce pack:</p>
<p style="text-align: center;">
  <img src="./assets/sample.png" />
</p>
<p>On ne va peut être pas arriver à ce résultat en 2h (ou ce qu'il reste du temps imparti), mais si vous continuez chez vous, vous pouvez y arriver sans problème assez rapidement.</p>
<h1><a class="header" href="#pratique---prise-en-main-de-godot" id="pratique---prise-en-main-de-godot">Pratique - Prise en main de Godot</a></h1>
<h2><a class="header" href="#ouverture-du-projet" id="ouverture-du-projet">Ouverture du projet</a></h2>
<p>On va commencer par ouvrir Godot puis charger le projet d'exemple dans <code>./sc-space-shooter-pack</code>.</p>
<p>Il faut appuyer sur le bouton <strong>&quot;Import&quot;</strong>.</p>
<p style="text-align: center">
  <img src="./assets/godot-project-manager.png">
</p>
<p>Et appuyer sur <strong>&quot;Importer&quot;</strong> après avoir sélectionné le chemin vers le projet.</p>
<p style="text-align: center">
  <img src="./assets/godot-project-manager-import.png">
</p>
<p>Normalement, vous devriez voir l'interface de Godot.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-full.png">
</p>
<h2><a class="header" href="#configuration-de-léditeur" id="configuration-de-léditeur">Configuration de l'éditeur</a></h2>
<p>Avant de commencer à jouer avec Godot, on va configurer l'intégration avec Visual Studio Code.</p>
<p>Il faut d'abord ouvrir les paramètres de l'éditeur.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-settings-popup.png">
</p>
<p>Puis aller dans la section <strong>&quot;Text Editor / External&quot;</strong>.<br />
Ici, il faudra:</p>
<ul>
<li>cocher la case <strong>Use External Editor</strong></li>
<li>mettre le chemin vers VSCode dans <strong>Exec Path</strong>
<ul>
<li>exemple: <code>C:/Users/Moi/AppData/Local/Programs/Microsoft VS Code/Code.exe</code></li>
</ul>
</li>
<li>mettre <code>{project} --goto {file}:{line}:{col}</code> dans <strong>Exec Flags</strong></li>
</ul>
<p style="text-align: center">
  <img src="./assets/godot-editor-settings-external.png">
</p>
<p>Et voilà, VS Code est intégré à Godot.</p>
<h2><a class="header" href="#et-si-on-jouait-avec-le-projet-" id="et-si-on-jouait-avec-le-projet-">Et si on jouait avec le projet ?</a></h2>
<p>Pour tester la scène courante (<code>GameScreen</code>), appuyez sur le clap en haut à droite.</p>
<p style="text-align: center">
  <img src="./assets/play-scene.png">
</p>
<p>Pour déplacer le vaisseau, utilisez les <strong>touches fléchées</strong> et la touche <strong>ESPACE (ou ENTREE)</strong> pour tirer.
Fermez la fenêtre quand vous en avez marre.</p>
<h2><a class="header" href="#bon-alors-a-quoi-ça-ressemble-tout-ça-dans-godot-" id="bon-alors-a-quoi-ça-ressemble-tout-ça-dans-godot-">Bon alors, a quoi ça ressemble tout ça dans Godot ?</a></h2>
<p>Godot repose sur un principe de scenes (scènes) et de nodes (noeuds).</p>
<p>Prenez la scène actuellement ouverte, <code>GameScreen</code>, et regardez la &quot;tree view&quot; en haut à gauche.</p>
<p style="text-align: center">
  <img src="./assets/treeview.png">
</p>
<p>Ici, on voit qu'il y a en tout 5 nodes dans cette scène, avec un noeud racine de type <code>Control</code> appelé <code>GameScreen</code>.
Chaque scène possède un noeud racine comme celui-ci.
Voici les nodes qui composent cette scène:</p>
<ul>
<li>Background (type <code>ColorRect</code>)
<ul>
<li>Définit une couleur à appliquer sur la scène, ici du noir.</li>
</ul>
</li>
<li>Player (type <code>Player</code> (custom))
<ul>
<li>Représente le joueur via une autre scène du projet.</li>
</ul>
</li>
<li>Spawner (type <code>Spawner</code> (custom))
<ul>
<li>Système de spawner qui peut faire apparaître n'importe quel type d'objet. C'est une autre scène du projet.</li>
</ul>
</li>
<li>Bullets (type <code>Node2D</code>)
<ul>
<li>Un conteneur pour stocker les balles qui seront instanciées.</li>
</ul>
</li>
</ul>
<p>Il existe plusieurs types de nodes dans Godot, et il est possible de créer ses propres nodes en partant de nodes déja existants et en leur liant des scripts. On verra des exemples par la suite.
Si ça vous semble un peu confus, c'est normal, on va pratiquer.</p>
<p>On va commencer à changer des trucs et créer de nouveaux nodes dans la prochaine partie.</p>
<h1><a class="header" href="#pratique---jouer-avec-les-nodes" id="pratique---jouer-avec-les-nodes">Pratique - Jouer avec les nodes</a></h1>
<p>On va commencer a jouer avec les nodes, en ajoutant facilement des features !</p>
<p>Voici ce qu'on va ajouter:</p>
<ul>
<li><a href="./PRACTICE-NODES-STARS.html">Un fond avec des étoiles</a></li>
<li><a href="./PRACTICE-NODES-ENEMY.html">Des ennemis</a></li>
<li><a href="./PRACTICE-NODES-HUD.html">Un HUD pour le score</a></li>
</ul>
<h1><a class="header" href="#un-fond-avec-des-étoiles" id="un-fond-avec-des-étoiles">Un fond avec des étoiles</a></h1>
<h2><a class="header" href="#préparation" id="préparation">Préparation</a></h2>
<p>Avec juste un fond noir ça fait pas vraiment espace, il manque un truc: des étoiles.<br />
Donc on va faire en sorte d'illuminer un peu tout ça, via une petite arnaque: on va utiliser un <strong>système de particules</strong>.</p>
<p>Avec un système de particules, on peut faire n'importe quoi:</p>
<ul>
<li>De la pluie,</li>
<li>De la neige,</li>
<li>Du feu,</li>
<li>Une explosion,</li>
<li>De la fumée,</li>
<li>Ou bien encore des étoiles !</li>
</ul>
<p>Faut pas avoir peur, un système de particules c'est assez simple finalement, ça a juste beaucoup d'options, ce qui fait qu'on peut faire ce qu'on veut.</p>
<p>Alors on va tout de suite créer notre première scène. Appuyez sur <strong>Scene -&gt; New Scene</strong>.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-new-scene.png">
</p>
<p>Un nouvel onglet est apparu, et sur la gauche vous avez le choix pour le node racine.<br />
Parmi les nodes proposés, il y a:</p>
<ul>
<li>2D Scene: Va choisir un node de type <code>Node2D</code> en racine.</li>
<li>3D Scene: Va choisir un node de type <code>Node</code> en racine.</li>
<li>User Interface: Va choisir un node de type <code>Control</code> en racine.</li>
<li>Custom Node: Va vous permettre de sélectionner un autre node.</li>
</ul>
<p style="text-align: center">
  <img src="./assets/godot-editor-new-scene-tree.png">
</p>
<p>Partez sur un node <code>Control</code>, et enregistrez la scène dans le dossier <code>res://fx/</code> sous le nom <code>Stars.tscn</code>.<br />
Renommez le node <code>Control</code> en <code>Stars</code>.
Puis changez le <code>Layout</code> du noeud pour le passer en <code>Full Rect</code>.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-layout.png">
</p>
<p>Le node va maintenant prendre toute la surface de l'app.<br />
On va créer un node de type <code>ColorRect</code> (en noir) qui va prendre toute la place du parent pour répliquer un semblant d'espace.</p>
<p>Il faut faire un clique droit sur le node <code>Stars</code> puis <code>Add Child Node</code>.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-add-child-node.png">
</p>
<p>Vous avez toute une série de nodes à disposition.<br />
Cherchez <code>ColorRect</code> puis appuyez sur <code>Create</code>.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-new-node.png">
</p>
<p>Recommencez l'opération avec le clique droit sur <code>Stars</code>, <code>Add Child Node</code> puis cherchez <code>Particles2D</code>.<br />
Vous devriez avoir cet arbre de nodes:</p>
<p style="text-align: center">
  <img src="./assets/particles-tree.png">
</p>
<h2><a class="header" href="#un-fond" id="un-fond">Un fond</a></h2>
<p>On va commencer par s'occuper du <code>ColorRect</code>. Cliquez dessus et regardez sur la droite.</p>
<p style="text-align: center">
  <img src="./assets/godot-editor-inspector.png">
</p>
<p>Godot se repose sur des concepts d'héritages, reprenant les principes de la POO. Ici, on voit 4 sections:</p>
<ul>
<li>ColorRect</li>
<li>Control</li>
<li>CanvasItem</li>
<li>Node</li>
</ul>
<p>On voit en fait ici l'héritage des noeuds. <code>ColorRect</code> hérite de <code>Control</code>, qui hérite de <code>CanvasItem</code>, qui hérite de <code>Node</code>.<br />
On peut depuis l'inspecteur changer chaque propriété exposée dans chacun de ces nodes.<br />
Ce qui nous intéresse ici, c'est le champ <code>Color</code> de <code>ColorRect</code>. Cliquez dessus et changez la couleur pour mettre du noir.</p>
<p>Le petit carré devrait devenir noir dans la vue principale au centre. On va le faire grandir pour qu'il prenne toute la place du parent, de la même façon que tout à l'heure: <code>Layout</code> &gt; <code>Full Rect</code>.</p>
<p style="text-align: center">
  <img src="./assets/particles-color-rect.png">
</p>
<p>On vient de répliquer le node <code>Background</code> de la scène <code>GameScreen</code> de tout à l'heure: on a un fond noir.</p>
<h2><a class="header" href="#des-étoiles" id="des-étoiles">Des étoiles</a></h2>
<p>On va se concentrer sur les particules maintenant.</p>
<p>Cliquez sur le node <code>Particles2D</code>, qui a un petit warning à coté: si vous survolez, il vous dit qu'il y a pas de <strong>material</strong> pour gérer les particules.</p>
<p>Avec Godot, il y a deux types de <strong>material</strong> pour les particules:</p>
<ul>
<li>ShaderMaterial: Utilisation d'un <strong>shader</strong>. Ca parle peut être à certains, le monde des shaders est un sujet hyper complexe, on ne va pas attaquer ça aujourd'hui.</li>
<li>ParticlesMaterial: Utilisation d'un <strong>material</strong> configurable depuis l'inspecteur, ce qu'on va choisir.</li>
</ul>
<p>Pour lier un <strong>material</strong>, il faut aller dans l'inspecteur à droite, puis choisir un <code>New ParticlesMaterial</code> dans la section <code>Particles2D</code> &gt; <code>Process Material</code> &gt; <code>Material</code>.</p>
<p style="text-align: center">
  <img src="./assets/process-material.png">
</p>
<p>Pour le configurer, il faut ensuite cliquer sur ce material, et les paramètres vont apparaître en dessous. C'est ici que tout va se passer.</p>
<p>On va commencer par déplacer le node sur la vue du centre pour le mettre au centre de la scène, soit en drag &amp; drop, soit en changeant la valeur dans <code>Node2D</code> &gt; <code>Transform</code> &gt; <code>Position</code>.
Si vous zoomez sur l'interface, vous voyez que le système de particules est actif, et que des particules sont bien générées.</p>
<p style="text-align: center">
  <img src="./assets/particles-position.png">
</p>
<p>D'ici, vous pouvez configurer le système de particules comme vous le voulez, jouer avec la couleur, la taille, la texture, la vitesse, la gravité, et plein d'autres paramètres.</p>
<p>Pour avoir un truc qui ressemble à un ensemble d'étoiles voici ce que je recommande:</p>
<ul>
<li><code>Emission Shape -&gt; Shape</code>: Choisir <code>Box</code></li>
<li><code>Emission Shape -&gt; Box Extents</code>: Choisir <code>(X: 250, Y: 425, Z: 1)</code></li>
<li><code>Gravity -&gt; Gravity</code> &gt; Choisir <code>(X: 0, Y: 0, Z: 0)</code></li>
</ul>
<p>Ca ressemble déja un peu à des étoiles.</p>
<ul>
<li><code>Scale -&gt; Scale</code>: Choisir <code>4</code></li>
<li><code>Scale -&gt; Scale Random</code>: Choisir <code>1</code></li>
<li><code>Scale -&gt; Scale Curve</code>: Choisir <code>New CurveTexture</code></li>
<li><code>Scale -&gt; Scale Curve -&gt; Curve</code>: Déplacer le dernier point vers le bas à 0</li>
</ul>
<p>Maintenant on va jouer avec la couleur.</p>
<ul>
<li><code>Color -&gt; Color Ramp</code>: Choisir <code>New GradientTexture</code></li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient</code>: Choisir <code>New Gradient</code></li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient -&gt; Gradient</code>: Cliquer sur le curseur à gauche, puis sur la couleur dans l'encart à droite, et choisir une couleur blanche (ou la couleur que vous souhaitez).</li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient -&gt; Gradient</code>: Cliquer sur le curseur à droite, puis sur la couleur dans l'encart à droite, et déplacer le curseur A (Alpha) à 0.</li>
</ul>
<p>Voilà, on a un effet &quot;fade-out&quot;.</p>
<p style="text-align: center">
  <img src="./assets/particles.gif">
</p>
<p>Tada, des étoiles !</p>
<p>Oubliez pas d'enregistrer la scène, on va pouvoir l'intégrer au <code>GameScreen</code>.</p>
<h2><a class="header" href="#intégration" id="intégration">Intégration</a></h2>
<p>Retournez sur le <code>GameScreen</code>, supprimez le node <code>Background</code> via un clique-droit et <code>Delete Node</code>.<br />
Ensuite, clique-droit sur le <code>GameScreen</code> puis <code>Instance Child Scene</code>, et ajoutez votre scène <code>Stars</code>.<br />
Si ce n'est pas le cas, déplacez le nouveau noeud <code>Stars</code> vers le haut de l'arbre, en premier sous <code>GameScreen</code>, et renommez le en <code>Background</code>.</p>
<p>Faites <code>Play Scene</code>, et voilà, les étoiles en action !</p>
<h1><a class="header" href="#des-ennemis" id="des-ennemis">Des ennemis</a></h1>
<p>Dans cette partie, on va faire un ennemi, prêt à être utilisé dans le jeu.</p>
<h2><a class="header" href="#préparation-1" id="préparation-1">Préparation</a></h2>
<p>C'est parti, <code>Scene -&gt; New Scene</code>, on part de <code>Custom Node</code>, on choisit un noeud <code>Area2D</code> et on enregistre sous <code>res://actors/Enemy.tscn</code>.<br />
On renomme le nouveau noeud en <code>Enemy</code> et on commence.</p>
<p>Alors tout d'abord, pourquoi <code>Area2D</code> ?<br />
C'est un node qui permet de gérer les collisions en se basant sur la position des objets, au lieu d'utiliser une simulation physique: c'est plus rapide.<br />
On aura besoin de ça pour détecter la collision avec les balles et le joueur.</p>
<p>On va avoir besoin des nodes suivants en enfant:</p>
<ul>
<li>Une image: donc d'un noeud <strong>Sprite</strong></li>
<li>Une forme pour gérer les collisions: <strong>CollisionShape2D</strong></li>
<li>Un système de particules: <strong>Particles2D</strong></li>
<li>Un système d'animation: <strong>AnimationPlayer</strong></li>
</ul>
<p>On va aussi instancier des scènes existantes (depuis les scènes du projet):</p>
<ul>
<li>Le système de balles: <strong>actors/BulletSystem.tscn</strong></li>
<li>Une explosion: <strong>fx/Explosion.tscn</strong></li>
</ul>
<p style="text-align: center">
  <img src="./assets/enemy-base.png">
</p>
<h2><a class="header" href="#préparation-de-larea2d" id="préparation-de-larea2d">Préparation de l'Area2D</a></h2>
<p>On va commencer par paramétrer le node racine, qui est un Area2D, en appuyant dessus. Dans l'inspecteur, ouvrez la sous-section <code>Area2D -&gt; Collision</code>.<br />
En laissant le curseur sur les premières cases, vous voyez le label attribué à chacune.</p>
<p>Une case correspond à un type d'objet, dans cette ordre là (que j'ai déja défini dans les paramètres du projet):</p>
<ul>
<li>Bit 0 (value 1): Player</li>
<li>Bit 1 (value 2): Rock</li>
<li>Bit 2 (value 4): Enemy</li>
<li>Bit 3 (value 8): Bullet</li>
</ul>
<p>Voici ce qu'il faut faire:</p>
<ul>
<li>Pour le champ Layer, ne cocher que la 3e case (correspondant à Enemy)</li>
<li>Pour le champ Mask, ne cocher que la 1ere et 4e case (Player et Bullet)</li>
</ul>
<p>Cela permet au système de détection de collisions de ne remonter que les collisions entre Enemy et Bullet, ou Enemy et Player (et non Enemy et Rock).</p>
<p style="text-align: center">
  <img src="./assets/enemy-collision.png">
</p>
<p>Ensuite, il faut aller dans la section <code>Node</code> en haut à droite, appuyer sur <code>Groups</code>, puis taper <code>Player</code> et appuyer sur <code>Add</code>, et hop, on a ajouté le groupe <code>Enemy</code> sur le noeud racine.</p>
<h2><a class="header" href="#choix-de-limage" id="choix-de-limage">Choix de l'image</a></h2>
<p>On appuie sur le <code>Sprite</code> dans la treeview, on choisit une image dans les assets en bas à droite dans le dossier <code>res://assets/textures/Enemies/</code>, et on fait un glisser-déposer dans le champ <code>Sprite -&gt; Texture</code> de l'inspecteur (on peut aussi appuyer sur le champ et faire <code>Load</code>).</p>
<p style="text-align: center">
  <img src="./assets/enemy-assets.png">
</p>
<p>Si besoin, on peut choisir une &quot;teinte&quot; en changeant la couleur dans le champ <code>CanvasItem -&gt; Visibility -&gt; Modulate</code>.</p>
<p>On est bon pour l'image.</p>
<h2><a class="header" href="#définition-du-shape-de-collision" id="définition-du-shape-de-collision">Définition du shape de collision</a></h2>
<p>On va maintenant spécifier la surface de contact de l'ennemi. Pour ça, on sélectionne le node <code>CollisionShape2D</code>, et on crée un nouveau <code>CircleShape2D</code> dans le champ <code>CollisionShape2D -&gt; Shape</code> de l'inspecteur.</p>
<p>Il y a deux façons pour définir la taille du shape: avec l'inspecteur en sélectionnant le shape, ou dans la vue centrale en zoomant et en déplaçant le point orange. Le shape apparaît en bleu.<br />
Faites en sorte que le shape recouvre le sprite de l'ennemi.</p>
<p style="text-align: center">
  <img src="./assets/enemy-shape.png">
</p>
<h2><a class="header" href="#effet-de-particules" id="effet-de-particules">Effet de particules</a></h2>
<p>Je vais aller vite sur les particules, vous pouvez faire ce que vous voulez.<br />
Voici ce que j'ai fait:</p>
<p>Côté <code>Particles2D</code>:</p>
<ul>
<li><code>Amount</code>: <code>30</code></li>
<li><code>Time -&gt; Lifetime</code>: <code>2</code></li>
<li><code>Time -&gt; Speed Scale</code>: <code>2</code></li>
<li><code>Drawing -&gt; Local Coords</code>: <code>Off</code></li>
</ul>
<p>Côté <code>ParticlesMaterial</code>:</p>
<ul>
<li><code>Emission Shape -&gt; Shape</code>: <code>Box</code></li>
<li><code>Emission Shape -&gt; Box Extents</code>: <code>(X: 30, Y: 30, Z: 1)</code></li>
<li><code>Spread -&gt; Spread</code>: <code>180</code></li>
<li><code>Gravity -&gt; Gravity</code>: <code>(X: 0, Y: 0, Z: 0)</code></li>
<li><code>Initial Velocity -&gt; Velocity</code>: <code>20</code></li>
<li><code>Angular Velocity -&gt; Velocity</code>: <code>100</code></li>
<li><code>Angular Velocity -&gt; Velocity Random</code>: <code>1</code></li>
<li><code>Scale -&gt; Scale</code>: <code>20</code></li>
<li><code>Scale -&gt; Scale Random</code>: <code>1</code></li>
<li><code>Scale -&gt; Scale Curve</code>: <code>New CurveTexture</code></li>
<li><code>Scale -&gt; Scale Curve -&gt; Curve</code>: Déplacer le premier point vers le bas à 0</li>
<li><code>Color -&gt; Color Ramp</code>: <code>New GradientTexture</code></li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient</code>: <code>New Gradient</code></li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient -&gt; Gradient</code>: Cliquer sur le curseur à gauche, puis sur la couleur dans l'encart à droite, et choisir une couleur violette (ou la couleur que vous souhaitez).</li>
<li><code>Color -&gt; Color Ramp -&gt; Gradient -&gt; Gradient</code>: Cliquer sur le curseur à droite, puis sur la couleur dans l'encart à droite, choisir une couleur noire et déplacer le curseur A (Alpha) à 0.</li>
</ul>
<p>Côté <code>CanvasItem</code>:</p>
<ul>
<li><code>Visibility -&gt; Show Behind Parent</code>: <code>On</code></li>
</ul>
<p>Ca devrait donner quelque chose comme ça:</p>
<p style="text-align: center">
  <img src="./assets/enemy-particles.gif">
</p>
<h2><a class="header" href="#configuration-du-bulletsystem" id="configuration-du-bulletsystem">Configuration du BulletSystem</a></h2>
<p>Côté <code>BulletSystem</code>, il faut:</p>
<ul>
<li>activer le <code>Enemy Mode</code>,</li>
<li>définir le <code>Fire Delay</code> à <code>1</code>,</li>
<li>et déplacer le noeud en dessous le vaisseau dans la vue centrale, pour que les lasers ne sortent pas du milieu du vaisseau.</li>
</ul>
<h2><a class="header" href="#animations" id="animations">Animations</a></h2>
<p>On va maintenant jouer avec le système d'animations, lors de l'impact d'un laser sur le vaisseau (<code>hit</code>), et lors de l'explosion (<code>explode</code>).<br />
Il faut également définir une animation où il ne se passe rien au cas où on voudrait réinitialiser certains paramètres (<code>idle</code>).</p>
<p>Il faut sélectionner le node <code>AnimationPlayer</code> dans la tree-view, et regarder le panel du bas, section <code>Animation</code>.</p>
<p style="text-align: center">
  <img src="./assets/animation.png">
</p>
<p>Pour créer une animation, il faut appuyer sur le bouton <code>Animation -&gt; New</code>, puis taper le nom de l'animation. Commencez par créer <code>idle</code>, et définissez la en tant qu'animation par défaut (en autoplay).</p>
<p style="text-align: center">
  <img src="./assets/animation-auto.png">
</p>
<p>Ensuite, on recrée une animation appelée <code>hit</code>, et on va commencer à animer.</p>
<p>Il faut savoir qu'avec Godot, la plupart des propriétés exposées dans l'inspecteur peuvent être animées. Pour cette animation, on va seulement changer la teinte du sprite de l'ennemi (soit <code>Sprite -&gt; CanvasItem -&gt; Visibility -&gt; Modulate</code>).
Pour ajouter une <strong>track</strong> à l'animation, pendant que le panel d'animation est ouvert, appuyez sur la clé sur le côté de la propriété à animer. Ici, il faut ajouter <code>Modulate</code>, puis appuyer sur <code>Create</code> lorsque la popup apparaît.</p>
<p style="text-align: center">
  <img src="./assets/animation-key.png">
</p>
<p>Pour faire un effet de couleur, on met le curseur sur <code>0.1</code> seconde, puis on change la couleur de la propriété <code>Modulate</code> pour mettre du <em>rouge vif</em>, et on appuie sur la clé à côté.<br />
Ensuite, on met le curseur sur <code>0.4</code> seconde, puis on remet la couleur en <em>blanc</em>, et on appuie sur la clé.<br />
Enfin, on change la durée de l'animation (en dessous du bouton <code>Edit</code> sur la droite du panel <code>Animation</code>) pour mettre <code>0.4</code>.</p>
<p style="text-align: center">
  <img src="./assets/animation-hit.png">
</p>
<p>Vous pouvez appuyer sur les boutons Play/Stop du panel d'animation pour avoir un aperçu de l'animation.</p>
<p>On continue en créant une nouvelle animation, appelée <code>explode</code>.</p>
<p>Tout comme pour <code>hit</code>, on va juste animer la propriété <code>Modulate</code>, pour simuler la &quot;disparition&quot; progressive de l'image.</p>
<p>Donc en s'assurant que le curseur est sur la position <code>0.0</code>, on appuie sur la clé à côté de <code>Modulate</code> avec la couleur <code>blanche</code>, puis on déplace le curseur sur <code>0.2</code>, on change la valeur de <code>Modulate</code> avec la couleur alpha à 0 pour rendre l'image transparente, et on ré-appuie sur la clé.</p>
<p>Enfin, on change la durée de l'animation à <code>0.2</code> seconde.</p>
<p style="text-align: center">
  <img src="./assets/animation-explode.png">
</p>
<h2><a class="header" href="#scripting-début" id="scripting-début">Scripting: début</a></h2>
<p>On va enfin commencer à coder ! (eh oui Coding Dojo).<br />
Sélectionnez le node racine <code>Enemy</code>, et appuyez sur le bouton avec un genre de parchemin dessus.</p>
<p style="text-align: center">
  <img src="./assets/enemy-script-button.png">
</p>
<p>Une popup devrait ensuite s'afficher sur les options de configuration du script, faites juste <code>Create</code> et <em>magie</em>, VSCode se réveille, avec ce contenu:</p>
<pre><code class="language-py">extends Area2D

# Declare member variables here. Examples:
# var a = 2
# var b = &quot;text&quot;

# Called when the node enters the scene tree for the first time.
func _ready():
    pass # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#    pass
</code></pre>
<p>Ceci est du GDScript. Prenez le temps de lire les commentaires.</p>
<p>On va enlever tout ce code et remplacer par ça:</p>
<pre><code class="language-py">extends Area2D

#######
# Enemy

signal exploded

# Max enemy speed
export (Vector2) var max_speed = Vector2(150, 75)
# Max hit points
export (int) var hit_points = 3

# Current velocity
var velocity = Vector2()
# Remaining hit points
var remaining_hit_points = 0
# Current accumulator
var accu = 0

onready var sprite = $Sprite
onready var explosion = $Explosion
onready var bullet_system = $BulletSystem
onready var animation_player = $AnimationPlayer
onready var particles = $Particles2D
onready var collision_shape = $CollisionShape2D

###################
# Lifecycle methods

func _ready():
    &quot;&quot;&quot;When node is ready in game tree.&quot;&quot;&quot;
    self.connect(&quot;area_entered&quot;, self, &quot;_on_area_entered&quot;)

    self.velocity.y = self.max_speed.y
    self.remaining_hit_points = self.hit_points

func _process(delta):
    &quot;&quot;&quot;Process each step.&quot;&quot;&quot;
    self.accu += delta
    self.velocity.x = sin(self.accu) * self.max_speed.x
    self.bullet_system.firing = true

    self.position += self.velocity * delta

    if self.accu &gt;= 2 * PI:
        self.accu -= 2 * PI

    self._wrap_position()

################
# Public methods

func hit():
    &quot;&quot;&quot;Hit the enemy.&quot;&quot;&quot;
    if self.remaining_hit_points &lt;= 0:
        return

    self.animation_player.play(&quot;hit&quot;)
    self.remaining_hit_points -= 1
    if self.remaining_hit_points &lt;= 0:
        self.explode()

func explode():
    &quot;&quot;&quot;Make it explode.&quot;&quot;&quot;
    # Reset velocity
    self.velocity = Vector2()
    self.collision_shape.set_deferred(&quot;disabled&quot;, true)
    self.emit_signal(&quot;exploded&quot;)

    self.particles.emitting = false
    self.animation_player.play(&quot;explode&quot;)
    self.explosion.play()
    yield(get_tree().create_timer(0.5), &quot;timeout&quot;)
    self.queue_free()

func prepare_for_spawn(spawner, x, y):
    &quot;&quot;&quot;Prepare for spawn (Spawner method).&quot;&quot;&quot;
    self.position.x = x
    self.position.y = y

#################
# Private methods

func _wrap_position():
    &quot;&quot;&quot;Wrap position on screen.&quot;&quot;&quot;
    var game_size = self.get_viewport().size
    var sprite_size = self.sprite.texture.get_size() * self.scale

    var x_lower_limit = -sprite_size.x / 2
    var x_upper_limit = game_size.x + sprite_size.x / 2
    var y_lower_limit = game_size.y + sprite_size.y / 2

    if self.position.x &lt; x_lower_limit:
        self.position.x = x_upper_limit
    elif self.position.x &gt; x_upper_limit:
        self.position.x = x_lower_limit

    if self.position.y &gt; y_lower_limit:
        self.queue_free()

#################
# Event callbacks

func _on_area_entered(area):
    &quot;&quot;&quot;When colliding with another area.&quot;&quot;&quot;
    if area.is_in_group(&quot;Bullet&quot;) and !area.enemy_mode:
        area.queue_free()
        self.hit()

</code></pre>
<p>Oui, ça fait pas mal, et y'a beaucoup de choses à expliquer, mais ce bout de script va donner vie à l'ennemi à l'écran. Avant d'expliquer le script, on va le voir à l'oeuvre.</p>
<h2><a class="header" href="#intégration-des-ennemis" id="intégration-des-ennemis">Intégration des ennemis</a></h2>
<p>Retournez sur le <code>GameScreen</code>.</p>
<p>On va ajouter un node de type <code>Spawner</code> pour faire apparaître des ennemis sur la scène.<br />
Clique droit sur le <code>GameScreen</code>, <code>Instance Child Scene</code>, et ajoutez <code>Spawner</code>. Renommez le <code>EnemySpawner</code>.<br />
Dans l'inspecteur, changez <code>Spawn Delay</code> à <code>5</code>, et dans la valeur <code>Scene</code>, chargez la scène <code>Enemy</code> qu'on a crée dans cette partie.</p>
<p>On va devoir un peu modifier le script de <code>GameScreen</code> d'abord:</p>
<ul>
<li>Sous la ligne <code>onready var rock_spawner = $RockSpawner</code>: ajouter la ligne:</li>
</ul>
<pre><code class="language-py">onready var enemy_spawner = $EnemySpawner
</code></pre>
<ul>
<li>Dans la fonction <code>_ready</code>: ajouter la ligne:</li>
</ul>
<pre><code class="language-py">self.enemy_spawner.connect(&quot;spawn&quot;, self, &quot;_on_enemy_spawn&quot;)
</code></pre>
<ul>
<li>Sous la fonction <code>_on_rock_spawn</code>: ajouter la fonction:</li>
</ul>
<pre><code class="language-py">func _on_enemy_spawn(spawner, element):
    element.connect(&quot;exploded&quot;, self, &quot;_on_enemy_exploded&quot;)
    element.bullet_system.connect(&quot;fire&quot;, self, &quot;_on_fire&quot;)
</code></pre>
<ul>
<li>Puis sous <code>_on_rock_exploded</code>: ajouter la fonction:</li>
</ul>
<pre><code class="language-py">func _on_enemy_exploded():
    self._add_score(500)
</code></pre>
<p>Faites <code>Play Scene</code>, et normalement, les ennemis devrait apparaître comme par magie toutes les 5 secondes et vous tirer dessus.</p>
<p style="text-align: center">
  <img src="./assets/game-enemies.png">
</p>
<h2><a class="header" href="#scripting-le-retour" id="scripting-le-retour">Scripting: le retour</a></h2>
<p>On va maintenant rentrer dans le détail du script.</p>
<pre><code class="language-py">extends Area2D

#######
# Enemy

signal exploded

# Max enemy speed
export (Vector2) var max_speed = Vector2(150, 75)
# Max hit points
export (int) var hit_points = 3

# Current velocity
var velocity = Vector2()
# Remaining hit points
var remaining_hit_points = 0
# Current accumulator
var accu = 0

onready var sprite = $Sprite
onready var explosion = $Explosion
onready var bullet_system = $BulletSystem
onready var animation_player = $AnimationPlayer
onready var particles = $Particles2D
onready var collision_shape = $CollisionShape2D

...
</code></pre>
<p>Sur cette première partie de script, on voit:</p>
<ul>
<li>Un signal <code>exploded</code>, émit quand l'ennemi explose,</li>
<li>Des variables exportés: celles-ci apparaissent dans l'inspecteur:
<ul>
<li><code>max_speed</code>: La vitesse max d'un ennemi, c'est un Vector2, un objet avec une coordonnée X et Y,</li>
<li><code>hit_points</code>: Le nombre de tirs qu'un ennemi peut recevoir avant d'exploser, un entier.</li>
</ul>
</li>
<li>Des variables non-exportées: celles-ci n'apparaissent pas dans l'inspecteur:
<ul>
<li><code>velocity</code>: La vélocité actuelle de l'ennemi, Vector2,</li>
<li><code>remaining_hit_points</code>: Nombre de tirs restants, entier,</li>
<li><code>accu</code>: Variable utilisée pour le mouvement des ennemis, entier.</li>
</ul>
</li>
<li>Des références vers des enfants du node courant: via la fonction <code>$</code>, on peut récupérer un noeud depuis le noeud courant en tapant son chemin, ici seulement son nom. <code>onready</code> veut dire que la variable sera automatiquement chargée lorsque le noeud sera intégré dans le game tree.
<ul>
<li><code>sprite</code>: Le sprite de l'ennemi,</li>
<li><code>explosion</code>: Une explosion,</li>
<li><code>bullet_system</code>: Le système qui s'occupe de la gestion des tirs,</li>
<li><code>animation_player</code>: Le système d'animation,</li>
<li><code>particles</code>: Le système de particules,</li>
<li><code>collision_shape</code>: Le shape de collision de l'ennemi.</li>
</ul>
</li>
</ul>
<p><em>Suivant,</em></p>
<pre><code class="language-py">...

###################
# Lifecycle methods

func _ready():
    &quot;&quot;&quot;When node is ready in game tree.&quot;&quot;&quot;
    self.connect(&quot;area_entered&quot;, self, &quot;_on_area_entered&quot;)

    self.velocity.y = self.max_speed.y
    self.remaining_hit_points = self.hit_points

func _process(delta):
    &quot;&quot;&quot;Process each step.&quot;&quot;&quot;
    self.accu += delta
    self.velocity.x = sin(self.accu) * self.max_speed.x
    self.bullet_system.firing = true

    self.position += self.velocity * delta

    if self.accu &gt;= 2 * PI:
        self.accu -= 2 * PI

    self._wrap_position()
    
...
</code></pre>
<p>Ces deux fonctions sont des méthodes dites de <em>lifecycle</em>, du <em>cycle de vie</em> de la scène:</p>
<ul>
<li><code>_ready</code>: Appelée lorsque le noeud est intégré dans le game tree, c'est ici qu'on fait les initialisations.
<ul>
<li>Ici, on connecte le signal <code>area_entered</code> exposé par le noeud courant (<code>Area2D</code>) sur une fonction appelée <code>on_area_entered</code>,</li>
<li>On définit la vélocité Y courante avec la valeur max,</li>
<li>Et on définit les points de vie restants avec la valeur de base.</li>
</ul>
</li>
<li><code>_process</code>: Appelée à chaque step de l'exécution de la scène. Dans une exécution à 60 FPS, elle est exécutée toutes les 16 ms. C'est ici qu'on fait les mises à jour des éléments de la scène. La variable <code>delta</code> contient le délai qui s'est écoulé depuis la dernière update.
<ul>
<li>Ici, on augmente la valeur de l'accumulateur,</li>
<li>On change la vélocité X suivant une sinusoïde pour donner un effet sympa,</li>
<li>On active le système de tir,</li>
<li>On définit la position de l'ennemi depuis sa vélocité,</li>
<li>On &quot;boucle&quot; la valeur de l'accumulateur pour éviter de partir dans l'infini,</li>
<li>On &quot;wrap&quot; la position de l'ennemi sur l'écran (fonction définie plus loin).</li>
</ul>
</li>
</ul>
<p>Vous vous demandez peut être à quoi sert ce <code>delta</code> et pourquoi <code>_update</code> est appelée aussi souvent.
Je vais pas rentrer trop dans le détail, des articles entiers ont été réalisés sur la gestion du &quot;time step&quot; dans le jeu vidéo, mais il faut savoir qu'il est nécessaire de &quot;découper&quot; l'exécution de cette façon pour que tout puisse se mettre à jour et s'afficher en même temps.</p>
<p><em>Suivant,</em></p>
<pre><code class="language-py">################
# Public methods

func hit():
    &quot;&quot;&quot;Hit the enemy.&quot;&quot;&quot;
    if self.remaining_hit_points &lt;= 0:
        return

    self.animation_player.play(&quot;hit&quot;)
    self.remaining_hit_points -= 1
    if self.remaining_hit_points &lt;= 0:
        self.explode()

func explode():
    &quot;&quot;&quot;Make it explode.&quot;&quot;&quot;
    # Reset velocity
    self.velocity = Vector2()
    self.collision_shape.set_deferred(&quot;disabled&quot;, true)
    self.emit_signal(&quot;exploded&quot;)

    self.particles.emitting = false
    self.animation_player.play(&quot;explode&quot;)
    self.explosion.play()
    yield(get_tree().create_timer(0.5), &quot;timeout&quot;)
    self.queue_free()

func prepare_for_spawn(spawner, x, y):
    &quot;&quot;&quot;Prepare for spawn (Spawner method).&quot;&quot;&quot;
    self.position.x = x
    self.position.y = y
    
...
</code></pre>
<p>Ici, on définit 3 fonctions:</p>
<ul>
<li><code>hit</code>: S'assure d'enlever un point de vie à l'ennemi:
<ul>
<li>D'abord, on quitte la fonction si on a plus de points (explode devrait déja avoir été appelé),</li>
<li>On exécute l'animation <code>hit</code>,</li>
<li>On enlève un point,</li>
<li>S'il n'y a plus de point: on appelle <code>explode</code>.</li>
</ul>
</li>
<li><code>explode</code>: Fait exploser l'ennemi:
<ul>
<li>D'abord, on reset la vélocité (ça évite de faire glisser l'ennemi n'importe où pendant qu'il explose),</li>
<li>On désactive le shape de collision (ça évite de bloquer les tirs du joueur pendant l'explosion),</li>
<li>On émet le signal <code>exploded</code>,</li>
<li>On désactive le système de particules,</li>
<li>On exécute l'animation <code>explode</code>,</li>
<li>On lance l'explosion,</li>
<li>On attend 0.5 secondes (explication ci-dessous),</li>
<li>Et enfin on programme la suppression du noeud.</li>
</ul>
</li>
<li><code>prepare_for_spawn</code>: Méthode nécessaire qui sera appelée depuis <code>Spawner</code>:
<ul>
<li>On définit juste la position depuis les valeurs envoyées depuis le spawner.</li>
</ul>
</li>
</ul>
<p>Petite explication sur le <code>yield</code> de <code>explode</code>: si à la place on avait fait quelque chose comme <code>sleep 0.5</code>, on aurait bloqué toute l'exécution du jeu. Hors ici on veut juste attendre avant d'appeler la méthode <code>queue_free</code> pour supprimer le node.</p>
<p>Ici, on crée un timer de 0.5 secondes à la volée via <code>get_tree().create_timer(0.5)</code>, et on attend le déclenchement du signal <code>timeout</code>, en redonnant la main au jeu (on met la fonction en &quot;pause&quot;).
Quand le signal a été émis, la fonction <code>explode</code> reprend la main, et on exécute bien <code>queue_free</code>, et ce sans bloquer le jeu.</p>
<p>C'est le fonctionnement même des fameuses <strong>coroutines</strong>, qu'on peut trouver dans la plupart des langages, comme en Python par exemple.</p>
<p><em>Suivant,</em></p>
<pre><code class="language-py">...

#################
# Private methods

func _wrap_position():
    &quot;&quot;&quot;Wrap position on screen.&quot;&quot;&quot;
    var game_size = self.get_viewport().size
    var sprite_size = self.sprite.texture.get_size() * self.scale

    var x_lower_limit = -sprite_size.x / 2
    var x_upper_limit = game_size.x + sprite_size.x / 2
    var y_lower_limit = game_size.y + sprite_size.y / 2

    if self.position.x &lt; x_lower_limit:
        self.position.x = x_upper_limit
    elif self.position.x &gt; x_upper_limit:
        self.position.x = x_lower_limit

    if self.position.y &gt; y_lower_limit:
        self.queue_free()

#################
# Event callbacks

func _on_area_entered(area):
    &quot;&quot;&quot;When colliding with another area.&quot;&quot;&quot;
    if area.is_in_group(&quot;Bullet&quot;) and !area.enemy_mode:
        area.queue_free()
        self.hit()
</code></pre>
<p>C'est la fin du script, on définit ici deux méthodes:</p>
<ul>
<li><code>_wrap_position</code>: Appelée dans le code de <code>_update</code>, permet de s'assurer que l'ennemi reste sur l'écran, et lorsqu'il traverse les bordures de l'écran lors de son déplacement, permet de le téléporter de l'autre coté:
<ul>
<li>On récupère la taille du jeu et du sprite,</li>
<li>On définit les limites min/max à atteindre,</li>
<li>Si on dépasse d'un côté on va de l'autre,</li>
<li>Si on dépasse du bas de l'écran, on détruit le node.</li>
</ul>
</li>
<li><code>_on_area_entered</code>: On l'a branchée dans la méthode <code>_ready</code>, permet de réagir aux collisions avec le noeud courant. Le paramètre <code>area</code> contient le noeud cible avec lequel l'ennemi a eu une collision.
<ul>
<li>Ici, on regarde si le noeud cible est dans le groupe <code>Bullet</code> et qu'il n'est pas en mode &quot;ennemi&quot;.</li>
<li>Si c'est le cas, c'est que c'est un tir du joueur, donc on supprime la balle (via <code>queue_free</code>, et on appelle <code>hit</code> sur l'ennemi)</li>
</ul>
</li>
</ul>
<p>Voilà, vous avez toutes les explications sur l'ennemi, ça fait beaucoup mais c'est pas vraiment compliqué finalement, et ça permet de faire pas mal de choses.</p>
<h1><a class="header" href="#un-hud-pour-le-score" id="un-hud-pour-le-score">Un HUD pour le score</a></h1>
<p>Plus simple que la partie précédente, on va mettre en place un petit HUD pour montrer le score actuel.</p>
<h2><a class="header" href="#préparation-2" id="préparation-2">Préparation</a></h2>
<p>On va faire une nouvelle scène (<code>Scene -&gt; New Scene</code>) et on part de <code>User Interface</code>, on renomme le noeud en <code>HUD</code> et on enregistre sous <code>res://ui/HUD.tscn</code>.</p>
<p>On a donc un noeud de type <code>Control</code>, qui permet de réaliser de l'UI.</p>
<p>On va aller vite: on va enchaîner les créations de noeud.
On va avoir besoin de cette arbre là sous le noeud <code>HUD</code>:</p>
<ul>
<li>Créer un <code>MarginContainer</code>,
<ul>
<li>Il faut définir son <code>Layout</code> à <code>Full Rect</code>,</li>
<li>Et changer les <code>Custom Constants</code> en mettant <code>20</code> partout, pour avoir un petit margin,</li>
<li>Ajouter un enfant <code>HBoxContainer</code>,
<ul>
<li>Dans <code>Size Flags</code>, décocher <code>Vertical -&gt; Fill</code>,</li>
<li>Ajouter un enfant <code>VBoxContainer</code> (<em>à renommer</em> <code>ScoreContainer</code>),
<ul>
<li>Dans <code>Size Flags</code>, cocher <code>Horizontal -&gt; Expand</code> (en plus de <code>Fill</code>),</li>
<li>Ajouter un enfant <code>Label</code>,
<ul>
<li>Taper <code>SCORE</code> dans <code>Text</code>,</li>
<li>Définir une <code>Font</code> dans <code>Custom Fonts</code> en choisissant <code>New Dynamic Font</code>
<ul>
<li>Puis dans <code>Font</code> charger <code>res://assets/fonts/kenvector_future.ttf</code>,</li>
<li>Et changer <code>Settings -&gt; Size</code> à <code>32</code>,</li>
</ul>
</li>
</ul>
</li>
<li>Ajouter un enfant <code>Label</code> (<em>à renommer</em> <code>Score</code>),
<ul>
<li>Taper <code>0</code> dans <code>Text</code>,</li>
<li>Définir une <code>Font</code> dans <code>Custom Fonts</code> en choisissant <code>New Dynamic Font</code>
<ul>
<li>Puis dans <code>Font</code> charger <code>res://assets/fonts/kenvector_future.ttf</code>,</li>
<li>Et changer <code>Settings -&gt; Size</code> à <code>24</code>,</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Ajouter un enfant <code>VBoxContainer</code> (<em>à renommer</em> <code>BestContainer</code>),
<ul>
<li>Dans <code>Size Flags</code>, cocher <code>Horizontal -&gt; Expand</code> (en plus de <code>Fill</code>),</li>
<li>Ajouter un enfant <code>Label</code>,
<ul>
<li>Taper <code>BEST</code> dans <code>Text</code>,</li>
<li>Changer <code>Align</code> pour <code>Right</code>,</li>
<li>Définir une <code>Font</code> dans <code>Custom Fonts</code> en choisissant <code>New Dynamic Font</code>
<ul>
<li>Puis dans <code>Font</code> charger <code>res://assets/fonts/kenvector_future.ttf</code>,</li>
<li>Et changer <code>Settings -&gt; Size</code> à <code>32</code>,</li>
</ul>
</li>
</ul>
</li>
<li>Ajouter un enfant <code>Label</code> (<em>à renommer</em> <code>Score</code>),
<ul>
<li>Taper <code>0</code> dans <code>Text</code>,</li>
<li>Changer <code>Align</code> pour <code>Right</code>,</li>
<li>Définir une <code>Font</code> dans <code>Custom Fonts</code> en choisissant <code>New Dynamic Font</code>
<ul>
<li>Puis dans <code>Font</code> charger <code>res://assets/fonts/kenvector_future.ttf</code>,</li>
<li>Et changer <code>Settings -&gt; Size</code> à <code>24</code>,</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Une fois que c'est fait, on devrait avoir ça:</p>
<p style="text-align: center; vertical-align: center;">
  <img src="./assets/hud-tree.png">
</p>
<p style="text-align: center">
  <img src="./assets/hud-view.png">
</p>
<h2><a class="header" href="#intégration-dans-le-jeu" id="intégration-dans-le-jeu">Intégration dans le jeu</a></h2>
<p>Dans la scène <code>GameScreen</code>, ajoutez un noeud de type <code>CanvasLayer</code> tout en bas de l'arbre, puis ajoutez la scène <code>HUD</code> en enfant.</p>
<p>Il faut maintenant brancher le HUD dans le script de <code>GameScreen</code>.</p>
<ul>
<li>Il faut ajouter deux références vers les labels du HUD sous les lignes <code>onready</code>:</li>
</ul>
<pre><code class="language-py">onready var hud_score = $CanvasLayer/HUD/MarginContainer/HBoxContainer/ScoreContainer/Value
onready var hud_best = $CanvasLayer/HUD/MarginContainer/HBoxContainer/BestContainer/Value
</code></pre>
<ul>
<li>Définir une fonction <code>_update_hud</code> sous <code>_add_score</code>:</li>
</ul>
<pre><code class="language-py">func _update_hud():
    self.hud_score.text = str(self.score)
    self.hud_best.text = str(self.best_score)
</code></pre>
<ul>
<li>Mettre à jour <code>_add_score</code> et ajouter à la fin:</li>
</ul>
<pre><code class="language-py">self._update_hud()
</code></pre>
<ul>
<li>Puis mettre à jour <code>_on_player_dead</code> pour ajouter à la fin:</li>
</ul>
<pre><code class="language-py">self._update_hud()
</code></pre>
<p>Faites <code>Play Scene</code>, et hop, le HUD devrait fonctionner.</p>
<p style="text-align: center">
  <img src="./assets/hud-game.png">
</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
